# 实现 useReducer

useReducer 是作为 useState 的替代方案。在某些 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。

## 使用 useReducer
我们这里写一个简单的用法，在此之前，需要在`demo/which-react.js`中将`useReducer`引入，并将`ReactDOM`更换为从`react-dom`引入

```js
import { Component, Fragment, useReducer } from 'react';
import ReactDOM from 'react-dom/client';

// import { Component, Fragment } from '../src/react';
// import ReactDOM from '../src/react-dom';

export {
	Component,
	Fragment,
	useReducer,
	ReactDOM
}
```

在`demo/src/main.jsx`中的 FunctionComponent 中添加`useReducer`
```tsx
function FunctionComponent(props) {

  const [state, dispatch] = useReducer(x => x + 1, 0)

  return (
    <div className='function'>
      <p>{props.name}</p>
      <div>{state}</div>
      <button onClick={dispatch} >+1</button>
    </div>
  )
}
```
那么每次点击`button`都会将`state` + 1，有了我们想要的效果，接下来我们去实现它

## 实现 useReducer
将 React 的引入重新设定为自己写的（修改which-react.js）

创建`src/ReactFiberHooks.ts`
```ts
export function useReducer(reducer, initalState) {
	
	const dispatch = () => {
		console.log('useReducer dispatch log')
	}
	// 暂时直接返回
	return [initalState, dispatch]
}

```
接着会发现点击 button 没有触发 dispatch 里的 console，这是因为我们还没有实现 React 事件，暂时只是将事件作为属性挂在dom上了

`src/utils.ts`
```ts
export function updateNode(node, nextVal) {
  Object.keys(nextVal).forEach(key => {
    if (key === 'children') {
      if (isStringOrNumber(nextVal[key])) {
        node.textContent = nextVal[key]
      }
    } else {
      node[key] = nextVal[key] // 这里直接当作属性放到 dom 上了
    }
  })
}
```

这里先简单处理一下，能让事件能响应（注意这里并不是真正的 React 事件实现方式）

```ts
export function updateNode(node: HTMLElement, nextVal) {
  Object.keys(nextVal).forEach(key => {
    if (key === 'children') {
      if (isStringOrNumber(nextVal[key])) {
        node.textContent = nextVal[key]
      }
    } else if (key.slice(0, 2) === 'on') {
      // 简单处理一下事件响应（并不是真正的React 事件）
      const eventName = key.slice(2).toLocaleLowerCase()
      node.addEventListener(eventName, nextVal[key])
    } else {
      node[key] = nextVal[key]
    }
  })
}
```

点击按钮能让`console.log('useReducer dispatch log')`执行出来了

### 实现mount 时的 useReducer
```ts
import { Fiber } from "./ReactFiber"

interface Hook {
	memoizedState: any, // state
	next: null | Hook // 下一个 hook
}

// 当前正在渲染的 fiber
let currentlyRenderingFiber: Fiber | null = null

// 没什么特别的意义，就是想返回一个 Fiber 类型 不让 ts 报错
function getCurrentlyRenderingFiber() {
	return currentlyRenderingFiber as Fiber
}

// 当前正在处理的 hook
let workInProgressHook: Hook | null = null

export function renderWithHooks(workInProgress: Fiber) {
	currentlyRenderingFiber = workInProgress
	currentlyRenderingFiber.memoizedState = null
	workInProgressHook = null
}

function updateWorkInProgressHook() {
	currentlyRenderingFiber = getCurrentlyRenderingFiber()
	let hook

	const current = currentlyRenderingFiber.alternate
	// current 存在说明是 update，否则就是 mount
	if (current) {
		// 复用之前的 hook
		currentlyRenderingFiber.memoizedState = current.memoizedState
		// 看是否是第一个 hook
		if (workInProgressHook) {
			// 不是，则拿到下一个 hook，同时更新 workInProgressHook
			workInProgressHook = hook = workInProgressHook.next
		} else {
			// 是第一个 hook ，拿到第一个hook
			workInProgressHook = hook = currentlyRenderingFiber.memoizedState
		}
	} else {
		// mount 时需要新建hook
		hook = {
			memoizedState: null, // state
			next: null // 下一个 hook
		}
		if (workInProgressHook) {
			workInProgressHook = workInProgressHook.next = hook
		} else {
			// 第一个 hook，将 hook 放到 fiber 的 state 上，同时更新 workInProgressHook
			workInProgressHook = currentlyRenderingFiber.memoizedState = hook
		}
	}
	// 最终返回 hook（也就是 workInProgressHook）
	return hook
}

export function useReducer(reducer, initalState) {
	currentlyRenderingFiber = getCurrentlyRenderingFiber()

	const hook = updateWorkInProgressHook()

	if (!currentlyRenderingFiber.alternate) {
		// 初次渲染时将默认数据放到 hook.memoizedState 上即可
		hook.memoizedState = initalState
	}

	const dispatch = () => {
		console.log('useReducer dispatch log')
	}

  // 返回 state
	return [hook.memoizedState, dispatch]
}
```

在处理 FunctionComponent 时更新正在处理的 fiber（也就是当前的这个函数）
```ts
// ReactFiberReconciler.ts
export function updateFunctionComponent(workInProgress: Fiber) {
	// 更新正在处理的 fiber
	renderWithHooks(workInProgress)
	const { type, props } = workInProgress
	const children = type(props)
	reconcileChildren(workInProgress, children)
}

```