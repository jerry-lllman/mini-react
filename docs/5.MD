

# React VDOM DIFF 

示例代码如下
```tsx
function FunctionComponent(props) {

  const [count, setCount] = useState(0)

  return (
    <div className='function'>
      <p>{props.name}</p>
      <div>
        <button onClick={() => setCount(count + 1)}>{count}</button>
        <ul>
          {
            (count % 2 ? [0, 1, 3, 4] : [0, 1, 2, 3, 4]).map(item => <li key={item}>{item}</li>)
          }
        </ul>
      </div>
    </div>
  )
}

```
## mount 

我们现处理 mount 时，`oldFiber`不存在时说明要么是新增的节点，要么是 mount 时，我们统一将其当作 mount 时来看待处理，先忽略 update 时新增


```typescript

function placeChild(
	newFiber: Fiber,
	lastPlacedIndex: number,
	newIndex: number,
	shouldTrackSideEffect: boolean
) {
	newFiber.index = newIndex
	if (!shouldTrackSideEffect) {
		// mount 时
		return lastPlacedIndex
	}

}


export function reconcileChildren(returnFiber: Fiber, children) {
	if (isStringOrNumber(children)) {

		return
	}
	const newChildren: any[] = isArray(children) ? children : [children]

	let oldFiber = returnFiber.alternate?.child

	// 用于判断是 returnFiber 初次渲染还是更新
	let shouldTrackSideEffect = !!returnFiber.alternate
	// 用于保存上个 fiber 节点
	let previousNewFiber: Fiber | null = null
	let newIndex = 0

	// 上次 dom 节点插入的位置
	let lastPlacedIndex = 0

	// 1. 初次渲染 （目前只有这种情况）
	// 2. 老节点复用完了，但是新节点还有
	if (!oldFiber) {
		// 没有老节点，说明是 mount （忽略 update 时）
		for (; newIndex < newChildren.length; newIndex++) {
			const newChild = newChildren[newIndex]
			if (newChild === null) {
				continue
			}
			const newFiber = createFiber(newChild, returnFiber)

			lastPlacedIndex = placeChild(
				newFiber,
				lastPlacedIndex,
				newIndex,
				shouldTrackSideEffect
			)

			if (previousNewFiber === null) {
				returnFiber.child = newFiber
			} else {
				previousNewFiber.sibling = newFiber
			}
			// 更新
			previousNewFiber = newFiber
		}

	}

	if (newIndex === newChildren.length) {
		deleteRemainingChildren(returnFiber, oldFiber)
		return
	}
}


```

